本章内容涵盖
- 了解在一个典型应用中会出现哪些Kubernetes的资源
- 添加pod启动后和停止前的生命周期钩子
- 在kubernetes中如何方便地管理应用
- 在pod 中使用init容器
  
---
### 17.1 集中一切资源
一个**典型的应用**包含了一个或多个**Deploy**或**sts**对象，这些对象中包含了一个或多个容器的**pod模板**，每个容器都有一个**存活探针**，并且为**容器提供的服务** （如果有的话）提供**就绪探针**。

提供服务的 **pod** 是通过一个或者多个**服务**来暴露自己的。当需要从集群外访问这些服务的时候，要么将这些服务配置为 **LoadBalancer** 或者 **NodePort** 类型的服务，要么通过 **Ingress** 资源来开放服务。

pod模板通常会引用两种类型的**私密凭据（Secret）**。一种是从私有镜像仓库拉取镜像时使用的；另一种是pod中运行的进程直接使用的。

私密凭据本身通常不是应用 manifest 的一部分，因为它们不是由应用开发者来配置，而是由运维团队来配置的。私密凭据通常会被分配给 **ServiceAccount** ， 然后**ServiceAccount** 会被分配给每个单独的 **pod** 。

一个应用还包含一个或者多个**ConfigMap**对象，可以用它们来初始化环境变 量， 或者在 **pod** 中 以 **configMap** 卷来挂载。有一些 pod 会使用额外的卷，例如**emptyDir**或**gitRepo**卷，而需要**持久化存储**的**pod**则需要**PersistentVolumeClaim卷**，

**PersistentVolumeClaim** 也是一个应用 **manifest** 的一部分，而被 **PersistentVolumeClaim** 所引用的 **StorageClass**（**PersistentVolume**）则是由系统管理员事先创建的。

在某些情况下，一个应用还需要使用**任务（Jobs）**和**定时任务（CronJobs）**，**守护进程集（DaemonSet ）**通常不是应用部署的一部分，但是通常由系统管理员创建，以在全部或者部分节点上运行系统服务。

**水平pod扩容器（HorizationPodAutoScaler）**可以由开发者包含在应用 manifest 中或者后续由运维团队添加到系统中。集群管理员还会创建**LimitRange**和**ResourceQuota**对象，以控制每个pod和所有pod的计算资源使用情况。

在应用部署后，各种 **Kubernetes 控制器**会自动创建其他的对象。其中包括**端点控制器** （Endpoint controller ）创建的服务端点（Endpoint ）对象，**部署控制器**（Deployment controller ）创建的 ReplicaSet 对象，以及由 ReplicaSet （ 或者 Job 、CronJob 、 Statefu!Set 、 DaemonSet ）创建的实际的 pod 对象。

---
### 17.2 了解pod的生命周期

我们之前说过，可以将 pod 比作只运行单个应用的虚拟机。尽管在 pod 中运行的应用和虚拟机中运行的应用没什么不同，但是还是存在显著的差异。 其中一个例子就是 pod 中运行的应用随时可能会被杀死，因为 Kubernetes 需要将这个 pod 调度到另外一个节点，或者是请求缩容。我们接下来将探讨这方面的内容。

---
### 17.2.1 应用必须预料到会被杀死或者重新调度
在 Kubernetes 之外，运行在虚拟机中的应用很少会被从一台机器迁移到另外一台。当一个操作者迁移应用的时候，他们可以重新配置应用并且于动检查应用是否在新的位置正常运行。借助于 Kubernetes ， 应用可以更加频繁地进行自动迁移而无须人工介入，也就是说没有人会再对应用进行配置并且确保它们在迁移之后能够正常运行。这就意味着应用开发者必须允许他们的应用可以被相对频繁地迁移。

---
### 预料到本地IP和主机名会发生变化
当一个 pod 被杀死井且在其他地方运行之后（技术上来讲是一个新的 pod 替换了旧的 pod ，旧 pod 没有被迁移），它不仅拥有了一个新的 IP 地址还有了一个新的名称和主机名。

大部分无状态的应用都可以处理这种场景同时不会有不利的影响，但是有状态服务通常不能。

StatefulSet 会保证在将应用调度到新的节点并启动之后，它可以看到和之前一样的主机名和持久化状态。当然 pod 的 IP 还是会发生变化，应用必须能够应对这种变化。 因此应用开发者在一个集群应用中不应该依赖成员的四地址来构建彼此的关系，另外如果使用主机名来构建关系，必须使用 StatefulSet 。

---
### 预料到写入磁盘的数据会消失
还有一件事情需要记住的是，在应用往磁盘写入数据的情况下， 当应用在新的pod 中启动后这些数据可能会丢失，**除非你将持久化的存储挂载到应用的数据写入路径&**。在 pod 被重新调度的时候，数据丢失是一定的，但是即使在没有调度的情况下，写入磁盘的文件仍然会丢失。

单个容器可能因为各种原因被重启，例如进程崩溃了，例如存活探针返回失败了，或者是因为节点内存逐步耗尽，进程被 OOMKiller 杀死了 。当上述情况发生时，pod还是一样的，但是容器确实全新的了，kubelet不会创建一个容器运行多次，而是会重新创建一个容器。

---
### 使用存储卷来跨容器持久化数据
---
当 pod 的容器重启后，本例中的应用仍然需要执行有大量计算过程的启动程序。这个或许不是你所期望的。 为了保证这种情况下数据不丢失，你需要至少使用一个pod 级别的卷（如emptyDir，挂载到pod的容器上）。 因为卷的存在和销毁与 pod 生命周期是一致的， 所以新的容器将可以重用之前容器写到卷上的数据。

有时候使用存储卷来跨容器存储数据是个好办法，但是也不总是如此。万一由于数据损坏（依赖卷上的数据）而导致新创建的进程再次崩溃昵？这会导致一个持续性的循环崩溃（pod会提示 CrashLoopBackOff状态）。 

如果不使用存储卷的话，新的容器会从零开始启动，并且很可能不会崩溃。 使用存储卷来跨容器存储数据是把双刃剑。 你需要仔细思考是否使用它们。

---
### 17.2.2 重新调度死亡的或者部分死亡的 pod
如果一个 pod 的容器一直处于崩溃状态， Kubelet 将会一直不停地重启它们。每次重启的时间间隔将会以指数级增加， 直到达到 5 分钟。 在这个 5 分钟的时间间隔中，pod 基本上是死亡了 ，因为它们的容器进程没有运行。 公平来讲，如果是个多容器的 pod ， 其中的一些容器可能是正常运行的，所以这个 pod 只是部分死亡了。 但是如果 pod 中仅包含一个容器，那么这个 pod 是完全死亡的而且己经毫无用处了，因为里面己经没有进程在运行了。

replicaSet 本身并不关心 pod 是否处于死亡状态，它只关心 pod 的数量是否匹配期望的副本数量，在这种情况下，副本数量确实是匹配的。

容器将会每5分钟重启一次，在这个过程中Kubernetes期望崩溃的底层原因会被解决。这个机制依据的基本原理就是将pod重新调度到其他节点通常并不会解决崩溃的问题，因为应用运行在容器的内部，所有的节点理论上应该都是相同的。虽然上面的情况并不总是如此，但是大多数情况下都是这样。

---
### 17.2.3 以固定顺序启动pod
pod中运行的应用和手动运行的应用之间的另外一个不同就是运维人员在手动
部署应用的时候知道应用之间的依赖关系，这样他们就可以按照顺序来启动应用。

---
### 了解pod是如何启动的
Kubernetes API服务器确实是按照YAML或者JSON文件中定义的对象的顺序来进行处理的，但是仅仅意味着它们在被写入到 etcd的时候是有顺序的。无法确保pod会按照那个顺序启动。

但是你可以阻止一个主容器的启动，直到它的预置条件被满足。这个是通过在pod中包含一个叫作init的容器 来实现的。

### init 容器介绍
除了常规的容器，pod还可以包括init容器。如容器名所示，它们 可以用来初始化pod, 这通常意味着向容器的存储卷中写入数据，然后将这个存储卷挂载到主容器中。

一个pod可以拥有任意数量的init容器。init容器是顺序执行的， 并且仅当最后一个init容器执行完毕才会去启动主容器。换句话说，init容器也可以用来延迟pod的主容器的启动。

创建一个init容器：  
```yaml
...
spec:
  initContainers:
  - name: i1
    image: init_cont:1.0
    command: [直到服务器准备好后，才可启动客户端主容器]
```

---
### 17.2.4 增加生命周期钩子
我们已经讨论了如果使用 init容器来介入pod的启动过程， 另外pod 还允许你
定义两种类型的生命周期钩子：  
- 启动后（Post-start）钩子
- 停止前（Pre-stop）钩子

这些生命周期 的钩子是基于每个容器来指定的，和init容器 不同的是 ，init容器是应用到整个pod。这些钩子，如它们的名字所示 ，是在容器启动后和停止前执行的。

生命周期钩子与存活探针和就绪探针相似的是它们都 可以：  
- 在容器内部执行一个命令
- 向URL发送HTTP GET 请求

